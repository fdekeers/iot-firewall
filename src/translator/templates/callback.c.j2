{% set current_state = namespace(value=0) %}
{% for policy in policies %}
{% if not policy.periodic %}
{% set policy_jinja = policy.name.replace('-', '_') %}

/**
 * @brief {{policy_jinja}} callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */
uint32_t callback_{{policy_jinja}}(int pkt_id, uint8_t *payload, void *arg) {
    printf("Received packet\n");
    {% if multithread and policy.counters %}
    uint8_t thread_id = *((uint8_t *) arg);
    {% endif %}
    {% if policy.nfq_matches %}
    // Skip layer 3 and 4 headers
    size_t skipped = get_ip_header_length(payload);
    {% if policy.custom_parser == 'http' %}
    uint16_t src_port = get_src_port(payload + skipped);
    {% endif %}
    skipped += get_tcp_header_length(payload + skipped);

    // Parse message
    {% if policy.custom_parser == "mdns" %}
    dns_message_t message = dns_parse_message(payload + skipped);
    dns_print_message(message);
    {% else %}
    {{policy.custom_parser}}_message_t message = {{policy.custom_parser}}_parse_message(payload + skipped
    {%- if policy.custom_parser == 'http' -%}
    , src_port
    {%- endif -%}
    );
    {{policy.custom_parser}}_print_message(message);
    {% endif %}
    {% endif %}
    uint32_t verdict = NF_DROP;

    {% if multithread %}
    {% if policy.transient %}
    // Initialize counters if not initialized yet
    if (!initial_values[thread_id].is_initialized) {
        initial_values[thread_id] = counters_init("{{nft_table}}", "{{policy_jinja}}");
    }
    {% endif %}

    // Custom match
    {% if policy.nfq_matches%}
    if (
        {% if policy.nfq_matches %}
        {{policy.nfq_matches[0]["forward"]}}
        {% for match in policy.nfq_matches[1:] %}
        && {{match["forward"]}}
        {% endfor %}
        {% endif %}
    ) {
    {% endif %}
        pthread_mutex_lock(&mutex);
        if (state == {{states[current_state.value]}}
        {% set previous_policy = policies[(loop.index - 2) % policies|length] %}
        {% if previous_policy.transient %}
            || state == {{states[current_state.value - 1]}}
        {% endif %}
        ) {
            {% if not policy.periodic and not policy.transient %}
            {% set current_state.value = (current_state.value + 1) % states|length %}
            state = {{states[current_state.value]}};
            {% endif %}
            {% if policy.transient %}
            if (
                {% if "packet-count" in policy.counters and "default" in policy.counters["packet-count"] %}
                counter_read_packets("{{nft_table}}", "{{policy.name}}") - initial_values[thread_id].packets_both >= {{policy.counters["packet-count"]["default"]}}
                {% elif "packet-count" in policy.counters and "out" in policy.counters["packet-count"] %}
                counter_read_packets("{{nft_table}}", "{{policy.name}}-out") - initial_values[thread_id].packets_out >= {{policy.counters["packet-count"]["out"]}}
                {% endif %}
                {% if policy.counters|length >= 2 %}
                &&
                {% endif %}
                {% if "duration" in policy.counters and "default" in policy.counters["duration"] %}
                counter_read_microseconds() - initial_values[thread_id].microseconds >= {{policy.counters["duration"]["default"]}}
                {% elif "duration" in policy.counters and "out" in policy.counters["duration"] %}
                counter_read_microseconds() - initial_values[thread_id].microseconds >= {{policy.counters["duration"]["out"]}}
                {% endif %}
            ) {
                {% set current_state.value = (current_state.value + 1) % states|length %}
                state = {{states[current_state.value]}};
                initial_values[thread_id].is_initialized = false;
            }
            {% endif %}
            pthread_mutex_unlock(&mutex);
            {% set previous_policy = policies[(loop.index - 2) % policies|length] %}
            {% if previous_policy.periodic %}
            {# TODO: remove rule if not needed #}
            {% endif %}
            {% set next_policy = policies[loop.index % policies|length] %}
            {% if policy.direction != "both" and next_policy.periodic %}
            {% set next_rules = next_policy.build_nft_rule(-1) %}
            // Add nftables rule for next match
            system("sudo nft add rule {{nft_table}} {{nft_chain}} {{next_rules['forward']}}");
            {% if 'backward' in next_rules %}
            system("sudo nft add rule {{nft_table}} {{nft_chain}} {{next_rules['backward']}}");
            {% endif %}
            {% endif %}
            verdict = NF_ACCEPT;
        {% if policy.direction != "both" or policy.nfq_matches%}
        } else {
            pthread_mutex_unlock(&mutex);
        }
        {% endif %}
    {% if policy.direction == "both" %}
    {% if policy.nfq_matches%}
    } else if (
        {% if policy.nfq_matches %}
        {{policy.nfq_matches[0]["backward"]}}
        {% for match in policy.nfq_matches[1:] %}
        {% if "backward" in match %}
        && {{match["backward"]}}
        {% endif %}
        {% endfor %}
        {% endif %}
    ) {
        pthread_mutex_lock(&mutex);
    {% else %}
        } else{% endif %} if (state == {{states[current_state.value]}}) {
            {% if not policy.periodic %}
            {% set current_state.value = (current_state.value + 1) % states|length %}
            state = {{states[current_state.value]}};
            {% endif %}
            pthread_mutex_unlock(&mutex);
            {% set next_policy = policies[loop.index % policies|length] %}
            {% if next_policy.periodic %}
            {% set next_rules = next_policy.build_nft_rule(-1) %}
            system("sudo nft add rule {{nft_table}} {{nft_chain}} {{next_rules['forward']}}");
            {% if 'backward' in next_rules %}
            system("sudo nft add rule {{nft_table}} {{nft_chain}} {{next_rules['backward']}}");
            {% endif %}
            {% endif %}
            verdict = NF_ACCEPT;
        } else {
            pthread_mutex_unlock(&mutex);
        }
    {% endif %}
    {% else %}
    {% if policy.transient %}
    // Initialize counters if not initialized yet
    if (!initial_values.is_initialized) {
        initial_values = counters_init("{{nft_table}}", "{{policy_jinja}}");
    }

    {% endif %}
    // Custom match
    if (
        {% set previous_policy = policies[(loop.index - 2) % policies|length] %}
        {% if previous_policy.transient %}
        ( {% endif %}
        state == {{states[current_state.value]}}
        {% if previous_policy.transient %} || state == {{states[current_state.value - 1]}} )
        {% endif %}
        {% for match in policy.nfq_matches %}
        && {{match["forward"]}}
        {% endfor %}
        {% if "packet-count" in policy.counters and "default" in policy.counters["packet-count"] %}
        && counter_read_packets("{{nft_table}}", "{{policy.name}}") - initial_values.packets_both <= {{policy.counters["packet-count"]["default"]}}
        {% elif "packet-count" in policy.counters and "out" in policy.counters["packet-count"] -%}
        && counter_read_packets("{{nft_table}}", "{{policy.name}}") - initial_values.packets_out <= {{policy.counters["packet-count"]["out"]}}
        {% endif %}
        {% if "duration" in policy.counters and "default" in policy.counters["duration"] %}
        && counter_read_microseconds() - initial_values.microseconds <= {{policy.counters["duration"]["default"]}}
        {% elif "duration" in policy.counters and "out" in policy.counters["duration"] %}
        && counter_read_microseconds() - initial_values.microseconds <= {{policy.counters["duration"]["out"]}}
        {% endif %}
    ) {
        {% if not policy.periodic %}
        {% set current_state.value = (current_state.value + 1) % states|length %}
        state = {{states[current_state.value]}};
        {% if policy.transient %}
        initial_values.is_initialized = false;
        {% endif %}
        {% endif %}
        {% if policies|length > 1 %}
        {% set next_policy = policies[loop.index % policies|length] %}
        {% if policy.direction != "both" and next_policy.periodic %}
        {% set next_rules = next_policy.build_nft_rule(-1) %}
        system("sudo nft add rule {{nft_table}} {{nft_chain}} {{next_rules['forward']}}");
        {% if 'backward' in next_rules %}
        system("sudo nft add rule {{nft_table}} {{nft_chain}} {{next_rules['backward']}}");
        {% endif %}
        {% endif %}
        {% endif %}
        verdict = NF_ACCEPT;
    {% if policy.direction == "both" %}
    } else if (
        state == {{states[current_state.value]}}
        {% for match in policy.nfq_matches %}
        {% if "backward" in match %}
        && {{match["backward"]}}
        {% endif %}
        {% endfor %}
    ) {
        {% if not policy.periodic %}
        {% set current_state.value = (current_state.value + 1) % states|length %}
        state = {{states[current_state.value]}};
        {% endif %}
        {% if policies|length > 1 %}
        {% set next_policy = policies[loop.index % policies|length] %}
        {% if next_policy.periodic %}
        {% set next_rules = next_policy.build_nft_rule(-1) %}
        system("sudo nft add rule {{nft_table}} {{nft_chain}} {{next_rules['forward']}}");
        {% if 'backward' in next_rules %}
        system("sudo nft add rule {{nft_table}} {{nft_chain}} {{next_rules['backward']}}");
        {% endif %}
        {% endif %}
        {% endif %}
        verdict = NF_ACCEPT;
    }
    {% endif %}
    {% endif %}
    {% if multithread and policy.nfq_matches %}
    }
    {% endif %}

    return verdict;
}
{% endif %}
{% endfor %}
