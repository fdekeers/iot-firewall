// THIS FILE HAS BEEN AUTOGENERATED. DO NOT EDIT.

/**
 * Nefilter queue for device xiaomi-cam and policy gateway_discover_camera
 */

// Standard libraries
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <pthread.h>
#include <assert.h>
// Custom libraries
#include "nfqueue.h"
#include "packet_utils.h"
#include "rule_utils.h"
// Parsers
#include "parsers/header.h"

// Constants
#define MAX_THREADS 2
#define NUM_STATES 2
#define NFQ_ID_BASE 10

typedef enum
{
    STATE_0,
    STATE_1,
} state_t;

state_t state = STATE_0;
uint8_t num_threads = 0;
pthread_mutex_t mutex;
initial_values_t initial_values[MAX_THREADS];

/**
 * @brief arp_request_from_gateway callback function, called when a packet enters the queue.
 *
 * @param pkt_id packet ID for netfilter queue
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */
uint32_t callback_arp_request_from_gateway(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
{
    printf("Received packet\n");
    uint32_t verdict = NF_ACCEPT;

    // Custom match
    pthread_mutex_lock(&mutex);
    if (state == STATE_0)
    {
        state = STATE_1;
        pthread_mutex_unlock(&mutex);
        verdict = NF_ACCEPT;
        printf("Accept: policy arp-request-from-gateway, backward = False, state = STATE_0\n");
    }
    else
    {
        pthread_mutex_unlock(&mutex);
    }

    return verdict;
}

/**
 * @brief arp_reply_from_camera callback function, called when a packet enters the queue.
 *
 * @param pkt_id packet ID for netfilter queue
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */
uint32_t callback_arp_reply_from_camera(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
{
    printf("Received packet\n");
    uint32_t verdict = NF_ACCEPT;

    // Custom match
    pthread_mutex_lock(&mutex);
    if (state == STATE_1)
    {
        state = STATE_0;
        pthread_mutex_unlock(&mutex);
        verdict = NF_ACCEPT;
        printf("Accept: policy arp-reply-from-camera, backward = False, state = STATE_1\n");
    }
    else
    {
        pthread_mutex_unlock(&mutex);
    }

    return verdict;
}

/**
 * @brief Program entry point
 *
 * @param argc number of command line arguments
 * @param argv list of command line arguments
 * @return exit code, 0 if success
 */
int main(int argc, char const *argv[])
{

    // Initialize state mutex
    int ret = pthread_mutex_init(&mutex, NULL);
    assert(ret == 0);

    // Initialize initial_values structures
    for (uint8_t i = 0; i < MAX_THREADS; i++)
    {
        initial_values[i].is_initialized = false;
    }

    // Create threads
    uint8_t i = 0;
    pthread_t threads[MAX_THREADS];

    // arp_request_from_gateway
    uint8_t thread_id_arp_request_from_gateway = i;
    thread_arg_t thread_arg_arp_request_from_gateway = {
        .queue_id = NFQ_ID_BASE + i,
        .func = &callback_arp_request_from_gateway,
        .arg = &thread_id_arp_request_from_gateway};
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *)&thread_arg_arp_request_from_gateway);
    assert(ret == 0);

    // arp_reply_from_camera
    uint8_t thread_id_arp_reply_from_camera = i;
    thread_arg_t thread_arg_arp_reply_from_camera = {
        .queue_id = NFQ_ID_BASE + i,
        .func = &callback_arp_reply_from_camera,
        .arg = &thread_id_arp_reply_from_camera};
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *)&thread_arg_arp_reply_from_camera);
    assert(ret == 0);

    // Wait forever for threads
    for (i = 0; i < MAX_THREADS; i++)
    {
        pthread_join(threads[i], NULL);
    }

    // Destroy mutex
    pthread_mutex_destroy(&mutex);

    return 0;
}